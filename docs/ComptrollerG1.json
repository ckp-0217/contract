{
    "methods": {
        "_become(address,address,uint256,uint256,bool)": {
            "stateMutability": "nonpayable",
            "code": "function _become(contract Unitroller unitroller, contract PriceOracle _oracle, uint256 _closeFactorMantissa, uint256 _maxAssets, bool reinitializing) external nonpayable",
            "inputs": {
                "unitroller": {
                    "type": "contract Unitroller"
                },
                "_oracle": {
                    "type": "contract PriceOracle"
                },
                "_closeFactorMantissa": {
                    "type": "uint256"
                },
                "_maxAssets": {
                    "type": "uint256"
                },
                "reinitializing": {
                    "type": "bool"
                }
            },
            "outputs": {}
        },
        "_setCloseFactor(uint256)": {
            "stateMutability": "nonpayable",
            "code": "function _setCloseFactor(uint256 newCloseFactorMantissa) external nonpayable returns (uint256)",
            "inputs": {
                "newCloseFactorMantissa": {
                    "type": "uint256",
                    "description": "New close factor, scaled by 1e18"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Sets the closeFactor used when liquidating borrows",
            "details": "Admin function to set closeFactor"
        },
        "_setCollateralFactor(address,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function _setCollateralFactor(contract CToken cToken, uint256 newCollateralFactorMantissa) external nonpayable returns (uint256)",
            "inputs": {
                "cToken": {
                    "type": "contract CToken",
                    "description": "The market to set the factor on"
                },
                "newCollateralFactorMantissa": {
                    "type": "uint256",
                    "description": "The new collateral factor, scaled by 1e18"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Sets the collateralFactor for a market",
            "details": "Admin function to set per-market collateralFactor"
        },
        "_setLiquidationIncentive(uint256)": {
            "stateMutability": "nonpayable",
            "code": "function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external nonpayable returns (uint256)",
            "inputs": {
                "newLiquidationIncentiveMantissa": {
                    "type": "uint256",
                    "description": "New liquidationIncentive scaled by 1e18"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Sets liquidationIncentive",
            "details": "Admin function to set liquidationIncentive"
        },
        "_setMaxAssets(uint256)": {
            "stateMutability": "nonpayable",
            "code": "function _setMaxAssets(uint256 newMaxAssets) external nonpayable returns (uint256)",
            "inputs": {
                "newMaxAssets": {
                    "type": "uint256",
                    "description": "New max assets"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Sets maxAssets which controls how many markets can be entered",
            "details": "Admin function to set maxAssets"
        },
        "_setPriceOracle(address)": {
            "stateMutability": "nonpayable",
            "code": "function _setPriceOracle(contract PriceOracle newOracle) external nonpayable returns (uint256)",
            "inputs": {
                "newOracle": {
                    "type": "contract PriceOracle"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Sets a new price oracle for the comptroller",
            "details": "Admin function to set a new price oracle"
        },
        "_supportMarket(address)": {
            "stateMutability": "nonpayable",
            "code": "function _supportMarket(contract CToken cToken) external nonpayable returns (uint256)",
            "inputs": {
                "cToken": {
                    "type": "contract CToken",
                    "description": "The address of the market (token) to list"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Add the market to the markets mapping and set it as listed",
            "details": "Admin function to set isListed and add support for the market"
        },
        "accountAssets(address,uint256)": {
            "stateMutability": "view",
            "code": "function accountAssets(address, uint256) external view returns (contract CToken)",
            "inputs": {
                "_0": {
                    "type": "address"
                },
                "_1": {
                    "type": "uint256"
                }
            },
            "outputs": {
                "_0": {
                    "type": "contract CToken"
                }
            }
        },
        "admin()": {
            "stateMutability": "view",
            "code": "function admin() external view returns (address)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "address"
                }
            }
        },
        "borrowAllowed(address,address,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external nonpayable returns (uint256)",
            "inputs": {
                "cToken": {
                    "type": "address",
                    "description": "The market to verify the borrow against"
                },
                "borrower": {
                    "type": "address",
                    "description": "The account which would borrow the asset"
                },
                "borrowAmount": {
                    "type": "uint256",
                    "description": "The amount of underlying the account would borrow"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Checks if the account should be allowed to borrow the underlying asset of the given market"
        },
        "borrowVerify(address,address,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function borrowVerify(address cToken, address borrower, uint256 borrowAmount) external nonpayable",
            "inputs": {
                "cToken": {
                    "type": "address",
                    "description": "Asset whose underlying is being borrowed"
                },
                "borrower": {
                    "type": "address",
                    "description": "The address borrowing the underlying"
                },
                "borrowAmount": {
                    "type": "uint256",
                    "description": "The amount of the underlying asset requested to borrow"
                }
            },
            "outputs": {},
            "notice": "Validates borrow and reverts on rejection. May emit logs."
        },
        "checkMembership(address,address)": {
            "stateMutability": "view",
            "code": "function checkMembership(address account, contract CToken cToken) external view returns (bool)",
            "inputs": {
                "account": {
                    "type": "address",
                    "description": "The address of the account to check"
                },
                "cToken": {
                    "type": "contract CToken",
                    "description": "The cToken to check"
                }
            },
            "outputs": {
                "_0": {
                    "type": "bool"
                }
            },
            "notice": "Returns whether the given account is entered in the given asset"
        },
        "closeFactorMantissa()": {
            "stateMutability": "view",
            "code": "function closeFactorMantissa() external view returns (uint256)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            }
        },
        "comptrollerImplementation()": {
            "stateMutability": "view",
            "code": "function comptrollerImplementation() external view returns (address)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "address"
                }
            }
        },
        "enterMarkets(address[])": {
            "stateMutability": "nonpayable",
            "code": "function enterMarkets(address[] cTokens) external nonpayable returns (uint256[])",
            "inputs": {
                "cTokens": {
                    "type": "address[]",
                    "description": "The list of addresses of the cToken markets to be enabled"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256[]"
                }
            },
            "notice": "Add assets to be included in account liquidity calculation"
        },
        "exitMarket(address)": {
            "stateMutability": "nonpayable",
            "code": "function exitMarket(address cTokenAddress) external nonpayable returns (uint256)",
            "inputs": {
                "cTokenAddress": {
                    "type": "address",
                    "description": "The address of the asset to be removed"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Removes asset from sender's account liquidity calculation",
            "details": "Sender must not have an outstanding borrow balance in the asset, or be providing neccessary collateral for an outstanding borrow."
        },
        "getAccountLiquidity(address)": {
            "stateMutability": "view",
            "code": "function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256)",
            "inputs": {
                "account": {
                    "type": "address"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                },
                "_1": {
                    "type": "uint256"
                },
                "_2": {
                    "type": "uint256"
                }
            },
            "notice": "Determine the current account liquidity wrt collateral requirements"
        },
        "getAssetsIn(address)": {
            "stateMutability": "view",
            "code": "function getAssetsIn(address account) external view returns (contract CToken[])",
            "inputs": {
                "account": {
                    "type": "address",
                    "description": "The address of the account to pull assets for"
                }
            },
            "outputs": {
                "_0": {
                    "type": "contract CToken[]"
                }
            },
            "notice": "Returns the assets an account has entered"
        },
        "isComptroller()": {
            "stateMutability": "view",
            "code": "function isComptroller() external view returns (bool)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "bool"
                }
            }
        },
        "liquidateBorrowAllowed(address,address,address,address,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function liquidateBorrowAllowed(address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 repayAmount) external nonpayable returns (uint256)",
            "inputs": {
                "cTokenBorrowed": {
                    "type": "address",
                    "description": "Asset which was borrowed by the borrower"
                },
                "cTokenCollateral": {
                    "type": "address",
                    "description": "Asset which was used as collateral and will be seized"
                },
                "liquidator": {
                    "type": "address",
                    "description": "The address repaying the borrow and seizing the collateral"
                },
                "borrower": {
                    "type": "address",
                    "description": "The address of the borrower"
                },
                "repayAmount": {
                    "type": "uint256",
                    "description": "The amount of underlying being repaid"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Checks if the liquidation should be allowed to occur"
        },
        "liquidateBorrowVerify(address,address,address,address,uint256,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function liquidateBorrowVerify(address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 repayAmount, uint256 seizeTokens) external nonpayable",
            "inputs": {
                "cTokenBorrowed": {
                    "type": "address",
                    "description": "Asset which was borrowed by the borrower"
                },
                "cTokenCollateral": {
                    "type": "address",
                    "description": "Asset which was used as collateral and will be seized"
                },
                "liquidator": {
                    "type": "address",
                    "description": "The address repaying the borrow and seizing the collateral"
                },
                "borrower": {
                    "type": "address",
                    "description": "The address of the borrower"
                },
                "repayAmount": {
                    "type": "uint256",
                    "description": "The amount of underlying being repaid"
                },
                "seizeTokens": {
                    "type": "uint256"
                }
            },
            "outputs": {},
            "notice": "Validates liquidateBorrow and reverts on rejection. May emit logs."
        },
        "liquidateCalculateSeizeTokens(address,address,uint256)": {
            "stateMutability": "view",
            "code": "function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint256 repayAmount) external view returns (uint256, uint256)",
            "inputs": {
                "cTokenBorrowed": {
                    "type": "address",
                    "description": "The address of the borrowed cToken"
                },
                "cTokenCollateral": {
                    "type": "address",
                    "description": "The address of the collateral cToken"
                },
                "repayAmount": {
                    "type": "uint256",
                    "description": "The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                },
                "_1": {
                    "type": "uint256"
                }
            },
            "notice": "Calculate number of tokens of collateral asset to seize given an underlying amount",
            "details": "Used in liquidation (called in cToken.liquidateBorrowFresh)"
        },
        "liquidationIncentiveMantissa()": {
            "stateMutability": "view",
            "code": "function liquidationIncentiveMantissa() external view returns (uint256)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            }
        },
        "markets(address)": {
            "stateMutability": "view",
            "code": "function markets(address) external view returns (bool isListed, uint256 collateralFactorMantissa)",
            "inputs": {
                "_0": {
                    "type": "address"
                }
            },
            "outputs": {
                "isListed": {
                    "type": "bool"
                },
                "collateralFactorMantissa": {
                    "type": "uint256"
                }
            }
        },
        "maxAssets()": {
            "stateMutability": "view",
            "code": "function maxAssets() external view returns (uint256)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            }
        },
        "mintAllowed(address,address,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function mintAllowed(address cToken, address minter, uint256 mintAmount) external nonpayable returns (uint256)",
            "inputs": {
                "cToken": {
                    "type": "address",
                    "description": "The market to verify the mint against"
                },
                "minter": {
                    "type": "address",
                    "description": "The account which would get the minted tokens"
                },
                "mintAmount": {
                    "type": "uint256",
                    "description": "The amount of underlying being supplied to the market in exchange for tokens"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Checks if the account should be allowed to mint tokens in the given market"
        },
        "mintVerify(address,address,uint256,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function mintVerify(address cToken, address minter, uint256 mintAmount, uint256 mintTokens) external nonpayable",
            "inputs": {
                "cToken": {
                    "type": "address",
                    "description": "Asset being minted"
                },
                "minter": {
                    "type": "address",
                    "description": "The address minting the tokens"
                },
                "mintAmount": {
                    "type": "uint256",
                    "description": "The amount of the underlying asset being minted"
                },
                "mintTokens": {
                    "type": "uint256",
                    "description": "The number of tokens being minted"
                }
            },
            "outputs": {},
            "notice": "Validates mint and reverts on rejection. May emit logs."
        },
        "oracle()": {
            "stateMutability": "view",
            "code": "function oracle() external view returns (contract PriceOracle)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "contract PriceOracle"
                }
            }
        },
        "pendingAdmin()": {
            "stateMutability": "view",
            "code": "function pendingAdmin() external view returns (address)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "address"
                }
            }
        },
        "pendingComptrollerImplementation()": {
            "stateMutability": "view",
            "code": "function pendingComptrollerImplementation() external view returns (address)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "address"
                }
            }
        },
        "redeemAllowed(address,address,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external nonpayable returns (uint256)",
            "inputs": {
                "cToken": {
                    "type": "address",
                    "description": "The market to verify the redeem against"
                },
                "redeemer": {
                    "type": "address",
                    "description": "The account which would redeem the tokens"
                },
                "redeemTokens": {
                    "type": "uint256",
                    "description": "The number of cTokens to exchange for the underlying asset in the market"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Checks if the account should be allowed to redeem tokens in the given market"
        },
        "redeemVerify(address,address,uint256,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function redeemVerify(address cToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external nonpayable",
            "inputs": {
                "cToken": {
                    "type": "address",
                    "description": "Asset being redeemed"
                },
                "redeemer": {
                    "type": "address",
                    "description": "The address redeeming the tokens"
                },
                "redeemAmount": {
                    "type": "uint256",
                    "description": "The amount of the underlying asset being redeemed"
                },
                "redeemTokens": {
                    "type": "uint256",
                    "description": "The number of tokens being redeemed"
                }
            },
            "outputs": {},
            "notice": "Validates redeem and reverts on rejection. May emit logs."
        },
        "repayBorrowAllowed(address,address,address,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function repayBorrowAllowed(address cToken, address payer, address borrower, uint256 repayAmount) external nonpayable returns (uint256)",
            "inputs": {
                "cToken": {
                    "type": "address",
                    "description": "The market to verify the repay against"
                },
                "payer": {
                    "type": "address",
                    "description": "The account which would repay the asset"
                },
                "borrower": {
                    "type": "address",
                    "description": "The account which would borrowed the asset"
                },
                "repayAmount": {
                    "type": "uint256",
                    "description": "The amount of the underlying asset the account would repay"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Checks if the account should be allowed to repay a borrow in the given market"
        },
        "repayBorrowVerify(address,address,address,uint256,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function repayBorrowVerify(address cToken, address payer, address borrower, uint256 repayAmount, uint256 borrowerIndex) external nonpayable",
            "inputs": {
                "cToken": {
                    "type": "address",
                    "description": "Asset being repaid"
                },
                "payer": {
                    "type": "address",
                    "description": "The address repaying the borrow"
                },
                "borrower": {
                    "type": "address",
                    "description": "The address of the borrower"
                },
                "repayAmount": {
                    "type": "uint256",
                    "description": "The amount of underlying being repaid"
                },
                "borrowerIndex": {
                    "type": "uint256"
                }
            },
            "outputs": {},
            "notice": "Validates repayBorrow and reverts on rejection. May emit logs."
        },
        "seizeAllowed(address,address,address,address,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function seizeAllowed(address cTokenCollateral, address cTokenBorrowed, address liquidator, address borrower, uint256 seizeTokens) external nonpayable returns (uint256)",
            "inputs": {
                "cTokenCollateral": {
                    "type": "address",
                    "description": "Asset which was used as collateral and will be seized"
                },
                "cTokenBorrowed": {
                    "type": "address",
                    "description": "Asset which was borrowed by the borrower"
                },
                "liquidator": {
                    "type": "address",
                    "description": "The address repaying the borrow and seizing the collateral"
                },
                "borrower": {
                    "type": "address",
                    "description": "The address of the borrower"
                },
                "seizeTokens": {
                    "type": "uint256",
                    "description": "The number of collateral tokens to seize"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Checks if the seizing of assets should be allowed to occur"
        },
        "seizeVerify(address,address,address,address,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function seizeVerify(address cTokenCollateral, address cTokenBorrowed, address liquidator, address borrower, uint256 seizeTokens) external nonpayable",
            "inputs": {
                "cTokenCollateral": {
                    "type": "address",
                    "description": "Asset which was used as collateral and will be seized"
                },
                "cTokenBorrowed": {
                    "type": "address",
                    "description": "Asset which was borrowed by the borrower"
                },
                "liquidator": {
                    "type": "address",
                    "description": "The address repaying the borrow and seizing the collateral"
                },
                "borrower": {
                    "type": "address",
                    "description": "The address of the borrower"
                },
                "seizeTokens": {
                    "type": "uint256",
                    "description": "The number of collateral tokens to seize"
                }
            },
            "outputs": {},
            "notice": "Validates seize and reverts on rejection. May emit logs."
        },
        "transferAllowed(address,address,address,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function transferAllowed(address cToken, address src, address dst, uint256 transferTokens) external nonpayable returns (uint256)",
            "inputs": {
                "cToken": {
                    "type": "address",
                    "description": "The market to verify the transfer against"
                },
                "src": {
                    "type": "address",
                    "description": "The account which sources the tokens"
                },
                "dst": {
                    "type": "address",
                    "description": "The account which receives the tokens"
                },
                "transferTokens": {
                    "type": "uint256",
                    "description": "The number of cTokens to transfer"
                }
            },
            "outputs": {
                "_0": {
                    "type": "uint256"
                }
            },
            "notice": "Checks if the account should be allowed to transfer tokens in the given market"
        },
        "transferVerify(address,address,address,uint256)": {
            "stateMutability": "nonpayable",
            "code": "function transferVerify(address cToken, address src, address dst, uint256 transferTokens) external nonpayable",
            "inputs": {
                "cToken": {
                    "type": "address",
                    "description": "Asset being transferred"
                },
                "src": {
                    "type": "address",
                    "description": "The account which sources the tokens"
                },
                "dst": {
                    "type": "address",
                    "description": "The account which receives the tokens"
                },
                "transferTokens": {
                    "type": "uint256",
                    "description": "The number of cTokens to transfer"
                }
            },
            "outputs": {},
            "notice": "Validates transfer and reverts on rejection. May emit logs."
        }
    },
    "events": {
        "Failure": {
            "code": "event Failure(uint256 error, uint256 info, uint256 detail)",
            "inputs": {
                "error": {
                    "type": "uint256",
                    "indexed": false
                },
                "info": {
                    "type": "uint256",
                    "indexed": false
                },
                "detail": {
                    "type": "uint256",
                    "indexed": false
                }
            }
        },
        "MarketEntered": {
            "code": "event MarketEntered(contract CToken cToken, address account)",
            "inputs": {
                "cToken": {
                    "type": "contract CToken",
                    "indexed": false
                },
                "account": {
                    "type": "address",
                    "indexed": false
                }
            }
        },
        "MarketExited": {
            "code": "event MarketExited(contract CToken cToken, address account)",
            "inputs": {
                "cToken": {
                    "type": "contract CToken",
                    "indexed": false
                },
                "account": {
                    "type": "address",
                    "indexed": false
                }
            }
        },
        "MarketListed": {
            "code": "event MarketListed(contract CToken cToken)",
            "inputs": {
                "cToken": {
                    "type": "contract CToken",
                    "indexed": false
                }
            }
        },
        "NewCloseFactor": {
            "code": "event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa)",
            "inputs": {
                "oldCloseFactorMantissa": {
                    "type": "uint256",
                    "indexed": false
                },
                "newCloseFactorMantissa": {
                    "type": "uint256",
                    "indexed": false
                }
            }
        },
        "NewCollateralFactor": {
            "code": "event NewCollateralFactor(contract CToken cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa)",
            "inputs": {
                "cToken": {
                    "type": "contract CToken",
                    "indexed": false
                },
                "oldCollateralFactorMantissa": {
                    "type": "uint256",
                    "indexed": false
                },
                "newCollateralFactorMantissa": {
                    "type": "uint256",
                    "indexed": false
                }
            }
        },
        "NewLiquidationIncentive": {
            "code": "event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa)",
            "inputs": {
                "oldLiquidationIncentiveMantissa": {
                    "type": "uint256",
                    "indexed": false
                },
                "newLiquidationIncentiveMantissa": {
                    "type": "uint256",
                    "indexed": false
                }
            }
        },
        "NewMaxAssets": {
            "code": "event NewMaxAssets(uint256 oldMaxAssets, uint256 newMaxAssets)",
            "inputs": {
                "oldMaxAssets": {
                    "type": "uint256",
                    "indexed": false
                },
                "newMaxAssets": {
                    "type": "uint256",
                    "indexed": false
                }
            }
        },
        "NewPriceOracle": {
            "code": "event NewPriceOracle(contract PriceOracle oldPriceOracle, contract PriceOracle newPriceOracle)",
            "inputs": {
                "oldPriceOracle": {
                    "type": "contract PriceOracle",
                    "indexed": false
                },
                "newPriceOracle": {
                    "type": "contract PriceOracle",
                    "indexed": false
                }
            }
        }
    },
    "errors": {},
    "path": "",
    "title": "Compound's Comptroller Contract",
    "details": "This was the first version of the Comptroller brains. We keep it so our tests can continue to do the real-life behavior of upgrading from this logic forward.",
    "author": "Compound",
    "name": "ComptrollerG1"
}